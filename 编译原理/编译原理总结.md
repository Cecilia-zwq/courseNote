编译原理

# 1 引论

编译器：将源程序编译成目标语言；目标程序可执行；速度快
解释器：对源程序逐个语句 解释 + 直接执行；速度慢，错误诊断好

![image-20240514194144042](编译原理.assets/image-20240514194144042.png)

编译器结构

![image-20240514194439230](编译原理.assets/image-20240514194439230.png)

- 分析 / 前端部分：对源语言进行分析并产生中间表示，与目标机器无关
    - 源程序 >>分解>> 单词元素 + 语法结构 >> 中间表示
    - 收集源程序的信息存放至符号表
- 综合 / 后端部分
    - 中间表示 + 符号表信息 >> 目标程序
- 前后端分开的好处：不同源语言和不同机器可以得到不同编译器的组合

编译过程

1. 词法分析：源程序字符流 >> 词法单元 <token-name, attributr-value> 序列
2. 语法分析：根据语法结构，使用 token-name 创建中间表示（如语法树）
3. 语义分析：利用语法树 + 符号表，检查源程序和语言定义是否一致（类型检查、自动类型转换等）
4. 中间代码生成：生成低级/类机器语言的中间表示；一般使用三地址代码
5. 中间代码优化：对中间代码优化改进
6. 代码生成：中间代码 >> 目标语言的指令；合理分配寄存器来存放变量的值

其它概念

- 符号表管理：记录源程序中变量的名字（以及各种属性）
- 出错管理：
    - 语法错误：不符合语法或词法规则（非法字符、少括号、少结尾）
    - 语义错误：不符合语义规则（说明、作用域、类型）

# 2 高级语言及其语法描述

## 程序语言的定义

= 语法定义 + 语义定义

- 语法：规定如何形成和产生一个合法的程序 = 词法规则 + 语法规则
    - 此法规则：单词符号（常数、标识符、基本字、算符、界符等）的形成规则
    - 语法规则：语法单位（表达式、语句、分程序、函数、过程、程序等）的形成规则

- 语义：规定程序在运行的时候做什么事，没有公认的描述形式

## 高级语言的一般特性

语言类型

- 过程式语言 / 强制式 *Fortran, C*
- 函数式语言 / 应用式
- 基于规则的语言
- 面向对象语言 *C++, Java*

数据类型与操作

- 初等数据类型：每个程序都有，并定义它们之间的运算
（数值数据、逻辑数据、字符数据、指针类型等）

- 数据结构：从初级数据定义复杂数据的手段
（数组、记录、表格、栈、队列等）

- 抽象数据类型：数据对象集合、作用于数据对象的抽象运算集合、封装

语句与控制结构

- 表达式：运算量 + 算符；形成规则与运算顺序一般与数学习惯一致
- 语句：执行性语句 and 说明性语句
	- 说明性语句：定义变量或运算
	- 执行性语句：描述程序动作；赋值句、控制句、输入/输出句

## 程序语言的语法描述

### 基础概念

**字母表$\Sigma$：**又穷 符号（字母、数字、标点符号等）集合

> 二进制字母表：{0, 1}
> ASCII字符集
> Unicodde字符集

**字母表上的运算**

- 乘积：$\Sigma_1$ $\Sigma_2$ = {ab|a $\in$ $\Sigma_1$ , b $\in$ $\Sigma_2$ }
- n次幂：来自字母表中的长度为n的符号串构成的集合
	- $\Sigma^0$ = ${ \varepsilon }$ （空串）
	- $\Sigma^n$ = $\Sigma^{n-1}$ $\Sigma^n$    n>=1
- 正闭包：所有有长度符号串狗证的集合
	- $\Sigma^{+}$ = $\Sigma_1$ $\cup$ $\Sigma_2$ $\cup$ ...
- 克林闭包：正闭包 + 空串；任意长度符号串集合
	- $\Sigma^{*}$ = $\Sigma_0$ $\cup$ $\Sigma_+$

**串**

字母表中符号的有穷序列；克林闭包的一个元素 s$\in$ $\Sigma^{*}$
串的长度：|s|，符号个数
空串：$ \varepsilon $，长度为0的串

**串上的运算**

- 连接 xy：把串y附加到串x的后面；x是前缀，y是后缀
空串是连接运算的单位元：$ \varepsilon s = s \varepsilon = s$
- n次幂：将n个串s前后连接
	- $s^0 = \varepsilon$
	- $s^n = s^{n-1} s$

### 文法

**形式语言：**使用公式定义的语言，可利用数学或机器来进行处理

**文法：**对语言语法结构的形式规则进行描述；根据文法可推导出句子

**语法规则：**建立一组规则（产生式），来描述句子的语法结构

#### 产生式

将终结符和非终结符组合成串的描述方法

$$
\alpha \rightarrow \beta
$$

- 读作：$\alpha$ 定义为 $\beta$ / $\alpha$ 由 $\beta$ 组成
- 产生式左部 / 头：$\alpha$ 文法符号集合的正闭包 (不可为空串)，至少包含一个非终结符
- 产生式右部 / 体： $\beta$  文法符号集合的克林闭包 (可为空串)

**产生式的简写**

对一组有相同左部的产生式：
$$
\alpha \rightarrow \beta_1, \alpha \rightarrow \beta_2, ..., \alpha \rightarrow \beta_n
$$
简写为
$$
\alpha \rightarrow \beta_1|\beta_2| ...|\beta_n
$$
$\beta_1$, $\beta_2$, ...,$\beta_n$ 称为 $\alpha$ 的<a id="候选式1">[候选式](#候选式2)</a>

#### 推导和规约

**直接推导：**用产生式的右部替换产生式的左部

![image-20240514222058692](编译原理.assets/image-20240514222058692.png)

![image-20240514222135729](编译原理.assets/image-20240514222135729.png)

**句型：**S经若干步推导出一个文法符号串，可以包含终结符、非终结符、空串
**句子：**S经若干步推导出一个**终结符串**，即不包含非终结符的句型

![image-20240514222540980](编译原理.assets/image-20240514222540980.png)

归约：推导的逆过程；一个特定串与某个产生式右部相对，将其替换为产生式的左部

#### 文法的形式定义

**形式文法 G = { $V_N, V_T, S, P$ }**

- $V_N$：非终结符号集合
- $V_T$：终结符号集合
    - $V_T$ $\cap$ $V_N$ = $\empty$
    - $V_T$ $\cup$ $V_N$ = 文法符号集合
- S：开始符号——文法中的最大语法成分
- P：产生式集合

**语言的形式化定义**

文法G生成的语言 L(G)：由文法 G 的开始符号 S 所推导出的所有**句子**所构成的集合

**符号约定**

终结符：字母表前面的小写字母 a, b, c
终结符号串：字母表后面的小写字母 u, v, ...,  y ,z
非终结符：字母表前面的大写字母 A, B ,C
文法符号（终结符或者非终结符）：字母表后面的大写字母 X Y Z
文法符号串：小写希腊字母 $\alpha ,\beta ,\gamma$
默认第一个产生式的左部是开始符号 S

### 语义分析树与二义性

语法分析树：将左部做为树的节点，右部的所有符号作为子节点，不断构建结点成一棵树；

- 根节点是文法开始符
- 叶子结点为终结符
- 中间结点为非终结符；表示某个产生式的以此应用

文法二义性：对同一个句子，可以进行不同的推导过程（语法分析树不一样，但是叶子结点一样）

解决方法：

- 改写成无二义性的文法
- 寻找一个合适的编译方法（规则）

给定一个句型/句子，可以画出一个语法树

- 短语：语法树任意一个子树，叶节点所组成的符号串
- 直接短语：层数为2的子树的短语
- 句柄：句型对应语法树最左侧的直接短语

### 形式语言分类

乔姆斯基把文法分成以下四种类型：

**0型文法**

- 无限制文法 / 短结构文法 （递归可枚举的）
Unrestricted Grammar / Phrase Structure Grammar PSG
- 文法中的任意一个产生式，左部至少包含1个非终结符
- ![image-20240514224639631](编译原理.assets/image-20240514224639631.png)

**1型文法**

- 上下文有关文法   Context-Sensitive Grammar  CSG
- 文法中的任意一个产生式，左部长度 <= 右部长度
- ![image-20240514224706943](编译原理.assets/image-20240514224706943.png)
- 不包含ε-产生式：产生式右部不能为空串ε

**2型文法**

- 上下文无关文法  Context-Free Grammar  CFG
- 产生式的左部是一个终结符
- ![image-20240514224834903](编译原理.assets/image-20240514224834903.png)

**3型文法**

- 正则文法 Regular Grammar,RG
- ![image-20240514225006877](编译原理.assets/image-20240514225006877.png)
- 可以描述程序设计语言的多数单词

**四种文法之间的关系**

![image-20240514225130895](编译原理.assets/image-20240514225130895.png)

0型到3型，限制增强，表达能力减弱
上下文足够描述多数程序设计语言

# 3 词法分析

## 词法分析简介

**词法分析器：**源程序字符串 $\Rightarrow$ 词法单元串

过滤空白、换行、制表符、注释等
将词素添加到符号表

**词法单元（Token）：**< 词法单元名，[属性值] >

- 表示词法单位**种类**的抽象符号
- 语法分析器通过单元名来确定词法单元序列的结构
- 属性值用于语义分析之后的阶段

**词素（Lexeme）：**源程序中的一串字符；可以和某个词法单元的模式匹配，成为一个词法单元示例

- 关键字：保留字/基本字，程序语言中由固定意义的标识符
- 标识符：表示名字的字符串
- 常数：分为整形、实型、布尔型等
- 运算符：+ - * / 等
- 界符：逗号分号括号等

**模式（Pattern）：**一类词法单元的源程序词素可能具有的通用形式

**识别方式：**

- LexemeBegin指针：指向当前词素的开始位置
- forward指针：一直向前扫描，直到发现可以匹配某个模式
- 加速方法：缓冲区对；哨兵标记

## 正则表达式

**正则表达式** ( Regular Expression,  RE )：描述正则语言的表示方法

给定字符集 $\Sigma$ = { c1, c2, ..., cn}，归纳定义：

- 空串 $\varepsilon$ 是正则表达式
- 任意 c $\in$ $\Sigma$，c 是正则表法式
- 如果M和N是正则表达式，则以下也是正则表达式
    - 选择|：M|N = {M, N}
    - 连接：MN = {mn|m$\in$M, n$\in$N}
    - 闭包\*：M\* = {$\varepsilon$, M, MM, MMM, ...}

**正则语言 / 正则集合：**可以用正则表达式 r 定义的语言 L(r) （ r推出的字符串集合）
![image-20240515105428238](编译原理.assets/image-20240515105428238.png)
![image-20240515105543989](编译原理.assets/image-20240515105543989.png)

正则文法G定义的语言 = 正则表达式r生成的语言

**正则表达式的代数定律**

![image-20240515110523754](编译原理.assets/image-20240515110523754.png)

**正则定义：**给一些RE命名，并在之后的RE中使用这些名字

## 有穷自动机

**有穷自动机  ( Finite Automata，FA）**

- 处理系统的数学模型
- 一系列离散的输入输出信息 + 有穷数目的内部状态
- 当前状态 + 当前输入信息 >> 后继行为 >> 内部状态改变

**状态转换图（Transition Graph）：**用于识别 / 接受一定的字符串。

- 状态 (State) ：表示为识别词素时的某个情况
	- 开始状态 / 初始状态：只有一个，用start箭头指向
	- 接受状态 / 最终状态：可以有多个，用双圈表示；已识别到一个词素
	*有\*的接受状态：识别到一个词素，但最后读入的符号不在该词素中*
	- 可看作对前面已处理状态的总结
- 边 (Edge) ：从一个状态指向另一个状态
	- 边的标号可以是一个或多个符号
	- 当前状态为s，下一个输入符号为a：从s离开、沿着标号为a的边到达下一个状态

**FA定义 / 接收的语言**

- 串x被有穷自动机接收：给定输入串x，存在一个从初始状态到某个终止状态的转换序列
- FA定义 / 接收的语言 L (M) ：可以被有穷自动机M接受的所有串的集合

**最长子串匹配原则** ( Longest String Matching Principle )

输入串有多个不同前缀被匹配，选择最长的匹配前缀

达到某个最终状态时，如果还有输入，DFA就继续前进，以寻找最长匹配

### NFA与DFA

**确定的有穷自动机D (Deterministic) FA**

在一个状态上，输入一个符号，最多只能通过一条边转移到一个状态

$$
M=(S，Σ，δ，s0，F)
$$

- S：有穷的状态集
- Σ：字母表 / 输入符号集合（不含空串ε）
- δ：转换函数，将S $\times$ Σ 映射到 S
$s \in S, a \in Σ$, δ (s, a)：从状态s出发，沿着标记为a的边所达的新状态

- s0：开始/初始状态，s0 $\in$ S
- F：接收/终止状态集合，F $\subseteq$ S

![image-20240515134233504](编译原理.assets/image-20240515134233504.png)

**非确定的有穷自动机 N (Nondeterministic) FA**

在一个状态上，输入一个符号，有多于一个状态可以转移

- δ：转换函数，将S $\times$ Σ 映射到 S的幂集
  $s \in S, a \in Σ$, δ (s, a)：从状态s出发，沿着标记为a的边所达的新状态**集合**

- DFN和NFA等价：可以识别相同的语言；可以相互转换
DFA是NFA的特例

- 带有 ε 边的NFA：δ 转移函数将 S $\times$ ($Σ$ $\cup$ {ε}) 映射到 S 的幂集
带有和不带有ε-边的NFA具有等价性

![image-20240515134257734](编译原理.assets/image-20240515134257734.png)

正则表达式 $\Leftrightarrow$ NFA $\Leftrightarrow$ DFA

![image-20240516001404443](编译原理.assets/image-20240516001404443.png)

### 正则表达式到NFA

==此部分需要看一下做题教程并写题==

**基本规则**

![image-20240516001729186](编译原理.assets/image-20240516001729186.png)

**归纳规则**

![image-20240516001754495](编译原理.assets/image-20240516001754495.png)

### NFA到DFA

==此部分需要看一下做题教程并写题==

### DFA简化

==此部分需要看一下做题教程并写题==

## 错误处理技术

**错误类型：**单词拼写错误；非法字符

**错误检测：**当前状态 and 当前输入符号在转换表中对应项为空，并且当前不是终止状态 $\Rightarrow$ 调用错误处理程序

**错误处理：**查找前面的状态传递过程中，最后的一个最终状态（见最长匹配）

- 找到：将对应于该最终态的字符与前面的所有字符组成一个单词；输入指针回到该字符，自动机回到初始状态，继续读入下一个字符
- 没找到：确定出错 $\Rightarrow$ 错误恢复策略

**错误恢复策略：**恐慌模式 (panic mode) 恢复

对剩余的输入不断删除字符，直到指向一个可以从当前状态走出的正确字符

# 4 语法分析

## 语法分析器

**语法分析作用**

获取词法分析器生成的词法单元串，验证该串可由源语言的文法生成
语法错误：报告错误信息
语法正确：生成语法分析树

![image-20240516004246757](编译原理.assets/image-20240516004246757.png)

**常用语法分析方法**

- 自顶向下：推导
	- 从开始符号出发，每步把一个非终结符号替换为它的产生式右部
	- 从root开始构造语法分析树
	- 常用于LL文法
- 自底向上：归纳
	- 识别出一个产生式的右部，将其替换为产生式左部
	- 从叶子开始构造语法分析树
	- 常用于LR文法
- 共同点
	- 从左到右逐个扫描词法单元
	- 只能处理特定类型的文法

**词法分析与语法分析的比较**

为什么词法分析和语法分析要使用两种不同技术？

- 将编译器拆分成不同组件
- 词法规则较简单，不需要复杂文法，正则表达式简介且足够；根据正则表达式构造词法分析器效率高

阶段|输入|输出|描述体系
-|-|-|-
词法|源程序符号串|词法单元序列|正则表达式
语法|词法单元序列|语法分析树|上下文无关文法

## 上下文无关文法

定义：对每个语法结构的处理与其所在上下文无关

产生式**左部是非终结符号**，右部是符号串

**上下文无关文法和正则表达式**

- CFG比正则表达式的表达能力更强
- 使用RE描述的构造可以用CFG描述，反之不成立
每个RE都是CFG，但CFG不一定是RE

> 有穷自动机不能计数，而NFA DFA RE等价，所以RE无法记录读入字符的个数；但是CFG可以表达出则以概念

**最左推导与最右推导**

进行推导时：对替换哪个终结符进行**顺序**约束

最左推导：每次选择最左非终结符号
最右推导：每次选择最右非终结符号

一个语法分析树只对应一个最左推导（或最右推导）

**二义性**文法（有多个语法分析树）对同一句子有多个最左 / 最右推导

## 文法改造技术

文法改造的必要性：

- 语法分析技术取决于所应用的文法
- 一些语法无法用CFG文法描述

==下面内容查看教程并做题==

### 消除二义性

**识别**二义性：考虑一个句子实例分别进行最左推导和最右推导，如果有两个不同的语法树，则是二义性

**消除**二义性：引入消除二义性的规则 或者 优先级

### 消除左递归

直接左递归：文法中存在一个 A $\Rightarrow$ A α 产生式
间接左递归：经过两步或两步以上推导产生的左递归

自顶向下语法分析（最左推导）不能处理左递归
自底向上的技术可以处理左递归

消除左递归

- 把左递归转换成右递归
- 引进非终结符和ε-产生式

### 提取左公因子

产生式具有相同的左公因子，推导式选择产生式会有冲突

## 自顶向下语法分析

从分析树的顶部（根节点）向底部（叶节点）方向构造分析树
$\Leftrightarrow$ 从文法开始符号 S 推导出词串 w

每一步推导需要做选择：

- 替换当前句型中的哪个非终结符
- 用该非终结符的哪个<a id="候选式2">[候选式](#候选式1)</a>进行替换

自顶向下的语法分析采用最左推导方式

- 每次选择当前句型中的最左终结符进行替换
- 根据输入流的下一个终结符，选择该非终结符的以个候选式

**递归下降分析**

- 一组分别对应一个非终结符的过程
- 从S对应的过程开始，递归调用其它非终结符的过程
- 如果可以不报错得读入所有输入串，则完成语法分析
- 可能回溯，效率低

![image-20240517110633476](编译原理.assets/image-20240517110633476.png)

**预测分析：**递归下降分析的特例

- 输入时前看固定个数的符号，根据它们来选择正确的非终结符产生式
	- 通常前看一个；对于前看k个：LL(k)文法类
	- 选出的候选式必须唯一
- 不需要回溯；确定的自顶向下分析

<a id="S文法">**S\_文法</a>：**简单的确定性文法

- 产生式右部都以终结符开始
- 同一个左部(非终结符)，其右部开始的终结符都不同
- 不含ε-产生式：产生式右部不能为空串

**是否选择非终结符的ε-产生式：**如果当前分析非终结符A，前看符号为a，两者不匹配时

- 若不存在 $A \rightarrow ε$：报错
- 若存在 $A \rightarrow ε$：若a可以出现在A的后面，选择此ε产生式，否则报错

### 符号集与可选集

==此处需要做题==

#### 非终结符的后继符号集 FOLLOW

**FOLLOW(A)：**在所有可能的句型中，紧跟在A后边的终结符集合

![image-20240517122636293](编译原理.assets/image-20240517122636293.png)

若A处在某个句型的结尾，则结束符 \$ $\in$ Follow(A)

#### 串首终结符集 FIRST

**串首终结符：**串的第一个符号，并且是终结符

**FIRST( $\alpha$ )**：可以从文法符号串$\alpha$推导出的所有串首终结符集合

![image-20240517124957249](编译原理.assets/image-20240517124957249.png)

**计算FIRST集合**

==此处需要做题==

#### 产生式的可选集 SELECT

**SELECT ( $A \rightarrow \beta$ )：**预测分析时，可以选用该产生式来推导的前看符号集合

- SELECT ( $A \rightarrow a \beta$ ) = {  a }
- SELECT ( $A \rightarrow \varepsilon$ ) = FOLLOW( A )

**q\_文法：**比[S\_文法](#S文法)能力强

- 产生式右部都以终结符开始或者为 $varepsilon$
- 同一个左部，不同的产生式可选集不相交

**根据$\alpha$的串首终结符计算产生式$A \rightarrow \alpha$的可选集**

![image-20240517125158292](编译原理.assets/image-20240517125158292.png)

### LL(1)文法分析

- 第一个L：从左向右扫描输入
- 第二个L：每次进行最左推导
- 1：每一步前看一个符号

文法G的任意两个左部相同的产生式 $A \rightarrow \alpha | \beta$ 满足如下条件时 $\Rightarrow$ G是LL(1)的

- FIRST( $\alpha$ )和FIRST( $\beta$ )不相交

-  $\alpha$ 和 $\beta$ 最多有一个能推导出 $\varepsilon$

![image-20240517130258795](编译原理.assets/image-20240517130258795.png)

**同一非终结符的各个产生式的可选集互不相交**

根据可选集构造**预测分析表**

![image-20240517132332061](编译原理.assets/image-20240517132332061.png)

#### 递归的预测分析法

在递归下降分析中，根据预测分析表进行产生式的选择

```
def A():
	// A对应的产生式为 A->X1,X2,...,Xk
	a = nextToken
	for i = 1 to k:
		if (Xi is 非终结符)： Xi()
		else if (Xi == a): a = nextToken
		else: error
```



#### 非递归的预测分析法

= **表驱动的预测分析：**根据预测分析表构造自动机

![image-20240517133516650](编译原理.assets/image-20240517133516650.png)

**输入**

- 字符串w
- 文法G的分析表M

**初始化**

- 缓冲区：w\$
- 输入指针ip：指向缓冲区第1位
- 栈：开始符号S位于栈顶；栈顶下一位是\$

**过程**

```
a = 句子第一位符号
X = 栈顶符号S
while X != $:
	if X == 终结符:
		if X == a: {pop(); a=nextToken()}
		if X != a: {error();}
	if X == 非终结符:
		if M[X, a] = null: {error();}
		if M[X, a] = (产生式X->Y1,Y2,...,Yk) :
			pop();
			push(Yk,...,Y2,Y1); //从右往左压栈，Y1位于栈顶
	X = 栈顶符号
```

![image-20240517163041449](编译原理.assets/image-20240517163041449.png)

#### 预测分析算法实现步骤

1. 构造文法

2. 改造文法：消除二义性、左递归、回溯

3. 求每个变量的FIRST集、FOLLOW集，求每个候选式的SELECT集

4. 检查是不是LL(1文法)，若是，构造预测分析表

5. 递归：为每个非终结符编写一个过程

    非递归：实现表驱动的预测分析算法

错误检测

- 栈顶终结符与当前输入符号不匹配
- 栈顶非终结符与当前输入符号在表中为空

错误恢复

- 栈顶不匹配：弹出栈顶不匹配的终结符
- 表项为空：忽略输入符号，直到输入出现在同步词法单元集合中
    - 非终结符A的同步记号集合：FOLLOW(A)里的终结符
- 表项设置为synch：弹出栈顶非终结符，继续分析后面的语法成分

## 自底向上语法分析

从底部 (叶节点) 向顶部 (根节点) 构造分析树
$\Leftrightarrow$ 输入串 w 归约为文法开始符号 S

自底向上的语法分析采用**最左归约**方式

每一步需要做选择：

- 继续读入终结符
- 对当前的一串终结符归约

$\Rightarrow$ 自底向上分析的通用框架：移入-归约分析 Shift-Reduce Parsing

### 移入-归约语法分析

- 移入：将下一个输入符号移到栈的顶端
- 归约：栈顶符号作为归约串的右端，在栈中确定归约串的左端，决定一个非终结符来替换
- 报错：发现语法错误，调用错误恢复子程序
- 接收：语法分析完成

工作过程：

1. 从左到右扫描串，每次移入0或多个输入符号到栈顶
2. 发现可以对栈顶的符号串进行归约，将其归约为某个产生式的左部
3. 重复步骤1、2，直到：
    - 检测出错误
    - 栈中为开始符号，且输入缓冲区为空：成功完成语法分析

### LR语法分析技术

**LR文法：**最大满足移入归约语法分析器的文法类

- 第一个L：从左向右扫描输入
- 第二个R：每次进行最最右推导
- LR(k)：每一步前看k个符号
省略k时表示1

**LR的总体结构**

![image-20240520200338441](编译原理.assets/image-20240520200338441.png)

**LR分析表**

![image-20240520202138594](编译原理.assets/image-20240520202138594.png)

**LR过程**

==见平板==

#### LR(0)分析

**增广文法**

G的增广文法G‘：为原先的开始符号S，加上新的开始符号S’，和新的产生式$S' \rightarrow S$

使文法开始符号仅出现在一个产生式的左边，从而使分析器只有接受状态

**LR(0)项目**：在产生式的右部有一个点号 $\cdot$

点号左边表示已经读入；右边表示剩余输入

![image-20240520204731556](编译原理.assets/image-20240520204731556.png)

**后继项目**

同一个产生式，但是点好位置差一位；点好靠后（读入字符多的）是前者的后继项目

$A \rightarrow \alpha \cdot X \beta$ 的后继项目是 $A \rightarrow \alpha X \cdot \beta$

**构造项目集**

![image-20240520220714217](编译原理.assets/image-20240520220714217.png)

初始产生式：点号位于产生式右部的起始，见上图每列的第一行

closure步骤：从(0)开始，找到将点号后有非终结符的项目，将非终结符对应的初始产生式放入到闭包中，不断更新

goto步骤：起始闭包完成后，对于闭包中的所有项目，找到后继项目（点号后移，将其点号后的符号读入）。对通过同一新符号转移的后继项目，组成集合，求闭包，成为新的状态。

不断构造closure，读入字符goto，转移至的新状态构造closure

![image-20240520221437329](编译原理.assets/image-20240520221437329.png)

**构造分析表**

构造出转换图图后，项目及$I_i$ 对应状态 i

- $I_i$ 中为归约项目（点号位于生成式最右一位）：
    - 左部是起符S'：ACTION(i, \$)=acc
    - 规约项目对应产生式n：ACTION(i, 任意符号)=rn
- $I_i$ 读入一个符号并转移至 $I_j$ 
    - 符号是终结符a：ACTION(i, a)=sj
    - 符号是终结符A：GOTO(i, A)=j
- 没有定义的条目为 error

**LR(0)自动机的形式化定义**

![image-20240520222748236](编译原理.assets/image-20240520222748236.png)

- 状态集：所有的项目集闭包 $I_i$ 的集合S
- 字母表：终结符和非终结符集合 $V_N \cup V_T$
- 状态转移函数：GOTO
- 初始状态：初始项目集闭包 $I_0$，见上图
- 终止状态：F，见上图

**LR(0)中的冲突**

对一个状态来说，可能既可以归约，又可以移进 $\Rightarrow$ 产生冲突

分析表中ACTION下某一cell，可能有多个可执行动作

**如果LR(0)分析表中没有冲突 $\Rightarrow$ 给定文法为LR(0)文法**

#### SLR分析

对于一个状态下：移进项目的移进字符集合{a1,a2,...} 与 归约项目的左部非终结符的FOOLOW集两两不相交，可如下解决

![image-20240520224549207](编译原理.assets/image-20240520224549207.png)

- 输入符号属于移进字符集，对应表格填shift
- 对于归约项目，找到左部的FOLLOW集合，将当前状态与集合中符号之间的表项填为reduce
- 其它位置报错

![image-20240520225056853](编译原理.assets/image-20240520225056853.png)

SLR分析表中没有冲突 $\Rightarrow$ SLR文法

#### LR(1)语法分析

在特定位置，出现在A后的符号集合是FOLLOW(A)的子集

SLR中的判读条件不一定是成立的

**LR(1)项目**

$$
[A \rightarrow \alpha \cdot \beta, a]
$$

在当前条件下，A后面必须紧跟的一个终结符（包括$）为a，称作该项的展望符

- $[A \rightarrow \alpha \cdot \beta, a]$ 且 $\beta \neq \epsilon$：a没作用
- $[A \rightarrow \alpha \cdot, a]$：下一个输入符号等于a，才可以归约

当点号后有非终结符时$[A \rightarrow \alpha \cdot B \beta, a]$，计算闭包：

- 找到B的产生式 $B \rightarrow \gamma$

- 加入 $[B \rightarrow \cdot \gamma, b]$

- 其中$b \in FIRST(\beta a)$  （自生的后继符）

    当$\beta \rightarrow \epsilon$ 时，b=a  （继承的后继符）

- 需要遍历所有可能取到的b，都放入项目中加入闭包


#### LALR语法分析

分析LR(1)中的项集，将所有项目第一部分都相同的集合进行合并，将第二部分用“或符号 /”来连接

根据合并后的项集构造分析表

如果分析表没有冲突，给定文法是LALR(1)文法

![image-20240524010826824](编译原理.assets/image-20240524010826824.png)

如图，$I_{10}$ $I_8$，$I_{11}I_{4}$，$I_{12}I_5$, $I_{13}I_7$ 都是第一部分一样的项集，可以进行合并，合并结果如下

![image-20240524011102925](编译原理.assets/image-20240524011102925.png)

LALR可能会推迟错误的发现 $\Rightarrow$ LALR(1)

LALR(1)

![image-20240524011457572](编译原理.assets/image-20240524011457572.png)

**二义性文法**

每个二义性文法都不是LR文法

**LR分析中的错误处理**

错误检测：查询分析表时发现报错条目，即检测到语法错误

错误恢复：设当前栈顶非终结符为A

- 恐慌模式：从栈顶开始向下扫描，直到发现某个状态s，它在A下有GOTO项目，则认从这个A推导出的串中包含错误

    丢弃0或多个输入符号，直到发现一个可能合法跟在A后的符号a

    将s之后的状态s'=GOTO(s, A)压入栈

- 短语层次：检查LR分析表中的每一个报错条目，并根据语言的使用方法来决定程序员所犯的何种错误最有可能引起这个语法错；然后构造出适当的恢复过程

## 语法分析器生成工具

YACC：C语言写的LALR语法分析器

# 5 语法制导的翻译

![image-20240525173537644](编译原理.assets/image-20240525173537644.png)

- 语法规则：上下文无关文法CFG
- 语义规则：CFG的一个产生式具有相应的语义规则
- 语义属性：为CFG中的文法符号设置语义属性，用来表示语义信息

## 语法制导定义 SDD

Syntax-Directed Definitions

SDD是CFG的推广

- 每个文法符号X关联一个语义属性集合 
X.a：符号X的属性a的值

- 每个产生式关联一组语义规则：对符号的属性值进行计算

![image-20240525174940056](编译原理.assets/image-20240525174940056.png)

### 综合属性和继承属性

利用语法分析树来分析：对于给定的输入串x，应用语义规则可以计算分析树中各结点对应的属性值

**综合属性 (synthesized attribute)** -自下而上传递信息

- 非终结符的综合属性`syn`：通过子节点或自己本身的属性值来定义
- 终结符的综合属性：由词法分析器提供词法值 
    - `lexval`：终结符的值
    - `lexeme`：终结符的字符串
- 放在语法分析树结点右边


![image-20240525180328657](编译原理.assets/image-20240525180328657.png)

带有综合属性的SDD

![image-20240525180814078](编译原理.assets/image-20240525180814078.png)

**继承属性 (inherited attribute)** - 自上而下

- 非终结符的继承属性`inh`：通过父节点、兄弟节点或自己本身的属性值来定义
- 终结符：没有继承属性
- 放在语法分析树结点左边

![image-20240525180348286](编译原理.assets/image-20240525180348286.png)

带有继承属性的SDD

![image-20240525180919285](编译原理.assets/image-20240525180919285.png)

虚综合属性依赖于括号内部的两个属性：如下图，5和3构成了6

### SDD的求值顺序

![image-20240530163334765](编译原理.assets/image-20240530163334765.png)

**属性值的依赖关系：**语义规则规定了依赖关系，对语法分析树的节点求属性值时，必须先求出所有依赖的属性值

**依赖图：**描述分析树节点之间依赖关系的有向图

- 结点的每个属性都对应依赖着一个结点
- 属性值X.a依赖于属性值Y.b：X.a $\leftarrow$ Y.b

**属性求值的顺序** $\Leftrightarrow$ **图的拓扑排序**

结点求值序列 N1, N2, ..., Nk要求：若依赖图中存在边Ni -> Nj，Ni要在序列上出现在Nj的前面

- Ni -> Nj 说明 Nj 依赖于 Ni，则先计算Ni才能计算Nj，Ni要在拓扑序的前面
- 图中如果没有环，就存在一个拓扑排序
	- 只具有综合属性的SDD：可按照任何自底向上的顺序计算属性值
	- 同时具有综合属性和继承属性SDD：不能完全保证一个求值顺序，可能是带环依赖图

### S-属性定义和L-属性定义

**S-属性定义 (S-SDD)**：仅使用综合属性的SDD

- 可按照语法分析树任何自底向上的顺序计算属性值
- 可以在自底向上的语法分析过程中实现

**L-属性定义 (L-SDD)**：继承只能从上到下、从左到右

满足每个属性都是综合属性，或者产生式 $A \rightarrow X_1,X_2,...,X_n$  中 $X_i$ 的继承属性仅依赖于

- A的继承属性
- $X_i$ 左边符号的属性
- $X_i$ 本身的属性，但 $X_i$ 的全部属性不能在依赖图中形成环路

每个S-属性定义都是L-属性定义

检查语义规则的等号左侧是不是继承属性：如果是，等号右边要满足上面的条件

## 语法指导翻译方案 SDT

SDT是对SDD的补充/实施方案

- 在CFG产生式右部直接插入语义规则/语义动作/程序片段
- 语义动作在产生式中的位置决定了这个动作的执行时间

![image-20240525200633845](编译原理.assets/image-20240525200633845.png)

### 将S-SDD转换为SDT

**转换规则：**将语义动作放在产生式的最后

**实现方法：**若S-SDD可使用LR分析，则在LR语法分析过程中实现SDT

- 在分析站中新增加一个域存放综合属性

![image-20240525202249560](编译原理.assets/image-20240525202249560.png)

- 在LR分析的归约发生时，执行相应的语义动作
  - 使用产生式右部符号的属性值计算产生式左部符号的属性值，计算方式由语义规则指定
  - 例如归约产生式$A \rightarrow XYZ$，则A.val = f(X.val, Y.val, Z.val) 
  - 将计算后的A.val放入综合属性下

![image-20240525202545242](编译原理.assets/image-20240525202545242.png)


### 将L-SDD转换为SDT

**转换规则**

- $A \rightarrow X_1X_2...X_n$
- 产生式右部符号$X_i$：将继承属性计算动作放在$X_i$的前面
- 产生式左部符号A：将综合属性计算动作放在$X_n$后面（右部的最后端）

![image-20240525204647054](编译原理.assets/image-20240525204647054.png)

**实现方法：**若L-SDD可以使用LL分析，则可以在LL或LR过程中实现SDT

#### LL递归下降中的翻译

对$A \rightarrow X_1,X_2,...,X_n$  

- 调用 $X_i()$ 之前计算 $X_i$的继承属性，作为分析函数的参数传入
- 在A()函数中的最后计算A的综合属性，并返回这个值

#### LL非递归中的翻译

扩展语法分析栈：

![image-20240530165601334](编译原理.assets/image-20240530165601334.png)

- A：存放A的继承属性
- Asyn：存放A的综合属性
- action：动作记录，指向语义动作的指针

对原LL进行修改

- 当前栈顶是非终结符A：
    - 只出栈符号本身，保留Asyn等待子节点计算
    - 出栈之前，将自身继承属性值附加给即将压入栈的语义动作（该动作会用到这个继承属性）
- 当前栈顶是Asyn：
    - 出栈之前，将自身综合属性值附加给旁边的语义动作
- 当前栈顶是终结符a：
    - 若输入缓存中的token与a匹配，将token赋给a的综合属性
    - 出栈之前，将自身综合属性值附加给旁边的语义动作
- 当前栈顶是动作记录：
    - 将自身得到的属性值用于动作计算

#### LR语法分析中的翻译

需要修改文法才能让L-SDD用LR语法分析进行处理

- 首先按照转换规则构造SDT
- 对每个内嵌的语义动作a，引入一个标记非终结符M（Marker Nonterminal）来替代它
- 标记非终结符M可推出空串$\epsilon$，并关联上与a等价的语义动作
    - 原本动作a要计算继承属性X.inh = compute(X1.xx, X2.xx)
    - 另M的继承属性继承被计算的值：M.inh1 = X1.xx；M.inh2 = X2.xx
    - 另M的综合属性成为计算后的值：M.syn = compute(M.inh1, M.inh2)

![image-20240526174826851](编译原理.assets/image-20240526174826851.png)

# 6 中间代码生成

![image-20240527143018115](编译原理.assets/image-20240527143018115.png)

以中间代码区分编译器的前端和后端

![image-20240526101414281](编译原理.assets/image-20240526101414281.png)

## 中间代码表示方式

编译器可以构造出一系列中间表示

![image-20240526102026509](编译原理.assets/image-20240526102026509.png)

- 高层表示：接近源语言，用于抽象表示代码结构
	- **后缀表达式**，又称为逆波兰表示法
		- 先写运算对象，操作符写在作用对象的后面 
		- 靠前的先计算，无需使用括号来表示优先级
	- **抽象语法树**
    
		- 刻画源程序的自然层次结构
		
		- 适用于静态类型检查 
	- **有向无环图DAG**
		- 每次构造新节点时，会检查节点是否已经存在
		- 可以自动提取左公因子
- 低层表示：接近目标机器
    - 选择不同的运算符，**三地址代码**既可以高层表示也可以低层表示

### 三地址代码

- 语法树或DAG的线性表示形式
- 一条指令的等号右侧最多有一个运算符
- 三地址码的名字对应语法树或DAG内部节点
- 适用于目标代码的生成和优化

三地址代码包含地址和指令

**地址：**表示变量或常量

- 变量的名字：指向符号表条目的指针
- 常量
- 临时变量

**指令**

- 双目运算：`x = y op z`
- 单目运算：`x = op y`
- 复制指令：`x = y`
- 无条件转移：`goto L`
- 条件转移：`if x goto L` / `if False x goto L` / `if x relation_op y goto L`
- 参数传递 / 过程调用 / 返回：`param x`, `call p` / `y = call p`, `return y`
- 带下标的复制：`x = y[i]` / `x[i] = y`
- 地址及指针赋值：`x = &y`, `x = *y`, `*x = y`

![image-20240526105711435](编译原理.assets/image-20240526105711435.png)

用数据结构表示三地址代码：四元式、三元式、间接三元式

**四元式：**`op`, `arg1`, `arg2`, `result` 四个字段

- 单目运算符不使用`arg2`
- param运算不使用`arg2`和`result`
- 条件转移 / 非条件转移将目标标号放在`result`字段

**三元式：**`op`, `arg1`, `arg2` 三个字段

- 运算的位置存放运算结果
- 移动、删除、添加三元式时，需要修改引用指令的位置
- DAG表示和三元式等价

![image-20240526110447958](编译原理.assets/image-20240526110447958.png)

**间接三元式：**一个指向三元式的指针列表

- 由上到下的运算的先后次序
- 优化时可以对指针列表进行操作，但不需要修改真正三元式中的参数

![image-20240526110806072](编译原理.assets/image-20240526110806072.png)

## 算数表达式的翻译

**文法属性**

符合|综合属性
-|-
S|S.code：三地址码
E|E.code：三地址码<br />E.addr：表达式值的地址（用名字表达）
id|id.lexeme：标识符地址（用名字表达）

**基本翻译**

算术表达式的SDD

- top.get(name)：查询符号表，返回name对应的存放地址
- gen(code)：生成指令
- new Temp()：生成临时变量 $t_i$，并返回地址 

![image-20240526153007544](编译原理.assets/image-20240526153007544.png)

*图中 `||` 是一个拼接，相当于拼出一个指令序列，序列不断增长*

**增量翻译**

不用code保存已有代码，而是对gen连续调用生成一个指令序列；相当于不断生成新指令，并保存下来

![image-20240526153311604](编译原理.assets/image-20240526153311604.png)



遇到newtemp()就使用一个新的临时变量，用来保存下面指令的运算结果

表达式的地址就是临时变量的地址

### 数组引用的翻译

**数组元素的寻址方式**

偏移量由索引序号 \* 类型宽度（例如int型是4）

![image-20240526154656355](编译原理.assets/image-20240526154656355.png)

**表达式加入数组的文法**

<img src="编译原理.assets/image-20240530195937594.png" alt="image-20240530195937594" style="zoom: 50%;" />

**文法属性**

符合|综合属性
-|-
S|S.code：三地址码
L|L.offset：用于计算偏移量的临时变量地址<br />L.array：数组名的入口地址<br />L.type：L生成的数组元素类型<br />
E|E.code：三地址码<br />E.addr：表达式值的地址（用名字表达）
id|id.lexeme：标识符地址（用名字表达）

E作为表达式，可以用来表达数组的偏移量

- type.elem：数组的元素类型

    下图中a的元素类型为 array(5,int)

- type.width：元素类型所占宽度

    int是4

![image-20240526155646011](编译原理.assets/image-20240526155646011.png)

**数组引用的SDT**

![image-20240526160326951](编译原理.assets/image-20240526160326951.png)



## 控制语句的翻译

<img src="编译原理.assets/image-20240530200713018.png" alt="image-20240530200713018" style="zoom: 67%;" />

控制流的翻译和布尔表达式的翻译结合在一起

布尔表达式的作用：改变控制流；计算逻辑值

**文法属性**

使用指令标号来表示三地址指令

布尔表达式B翻译成由跳转指令构成的跳转代码

符合|综合属性|继承属性
-|-|-
S|S.code：三地址码|S.next：紧跟在S之后的指令（后继指令）标号
B|B.code：三地址码|B.true：B为真时跳转的指令标号<br />B.false：B为假时跳转的指令标号

**控制流语句的代码结构**

对 S $\rightarrow$ if B then S1 else S2

<img src="编译原理.assets/image-20240530201433594.png" alt="image-20240530201433594" style="zoom:50%;" />



**控制流语句的SDD**

<img src="编译原理.assets/image-20240526162803082.png" alt="image-20240526162803082" style="zoom: 67%;" />

- newlabel()：生成一个记录指令标号的新临时变量L
- label(L)：让L存放下一条指令的标号

**控制流语句的SDT**

把继承属性（true false next）的计算放在对应终结符前

由于在S没有明确之前，S.next是未知的，所以需要先另S.next是个空地儿，确定后再用函数填写

计算继承属性时，可以利用父节点或左边兄弟节点的继承属性，所以S2.next=S.next

<img src="编译原理.assets/image-20240530203549727.png" alt="image-20240530203549727" style="zoom: 40%;" />

<img src="编译原理.assets/image-20240530204608959.png" alt="image-20240530204608959" style="zoom: 40%;" />

<img src="编译原理.assets/image-20240530204638397.png" alt="image-20240530204638397" style="zoom:40%;" />

<img src="编译原理.assets/image-20240530204703456.png" alt="image-20240530204703456" style="zoom:40%;" />

## 布尔表达式的翻译

**布尔表达式文法**

<img src="编译原理.assets/image-20240526181645593.png" alt="image-20240526181645593" style="zoom: 60%;" />

**代码短路**

- 把逻辑运算符（not;and;or）翻译成跳转指令，逻辑运算符本身不会出现在指令中

- 由 or / and 连接的B可以进行短路简化，如果判断结束就直接跳转到S

<img src="编译原理.assets/image-20240526223742060.png" alt="image-20240526223742060" style="zoom:60%;" />

**布尔表达式的SDT**

表达式为真，跳转到B.true；表达式为假，跳转到B.false

<img src="编译原理.assets/image-20240530205637666.png" alt="image-20240530205637666" style="zoom:50%;" />

可以画一个逻辑图来翻译代码

<img src="编译原理.assets/image-20240530205740018.png" alt="image-20240530205740018" style="zoom:50%;" />

<img src="编译原理.assets/image-20240530205811197.png" alt="image-20240530205811197" style="zoom:50%;" />

## 回填技术

对于 `if (B) S`，短路代码翻译时，有些指令会跳过代码块S，但是生成跳转指令时S的代码尚未生成，跳转的目标并不确定 $\Rightarrow$ 回填技术

生成跳转指令时不指定跳转目标，而是将所有跳转目标相同的指令的编号放入到同一个列表中，当知道正确的跳转目标编号时再进行填写

### 布尔表达式的回填

**文法属性**

符号|综合属性
-|-
S|S.code：三地址码<br />S.nextlist：跳转目标是原S.next
M|M.instr：紧接着的下一条指令的标号
B|B.truelist：跳转目标是B.true的指令列表<br />B.falselist：跳转目标是B.false的指令列表

**辅助函数**

- `makelist(i)`：创建一个跳转目标为i的指令列表
- `merge(p1,p2)`：将指令编号列表p1和p2合并然后返回
- `backpatch(p,i)`：对于编号列表p中的所有指令，将其跳转目标填写为i

<img src="编译原理.assets/image-20240530213948272.png" alt="image-20240530213948272" style="zoom:50%;" />

加入一个标记非终结符M，M的语义动作就是为了B1的回填而服务

<img src="编译原理.assets/image-20240530213619803.png" alt="image-20240530213619803" style="zoom:50%;" />

<img src="编译原理.assets/image-20240530213736023.png" alt="image-20240530213736023" style="zoom:50%;" />

### 控制语句的回填

符号|综合属性
-|-
S|S.code：三地址码<br />S.nextlist：跳转目标是原S.next的指令列表
B|B.truelist：跳转目标是B.true的指令列表<br />B.falselist：跳转目标是B.false的指令列表
M|M.instr：下一条指令的标号
N|N.nextlist：goto指令的标号

标记非终结符M，M语义动作存在的意义是为了回填B

<img src="编译原理.assets/image-20240530215111917.png" alt="image-20240530215111917" style="zoom: 50%;" />

标记非终结符N，N语义动作存在的意义是为了生成goto指令，在S1结束后跳过S2

<img src="编译原理.assets/image-20240530215234163.png" alt="image-20240530215234163" style="zoom:50%;" />

<img src="编译原理.assets/image-20240530220025636.png" alt="image-20240530220025636" style="zoom:50%;" />

<img src="编译原理.assets/image-20240530220958264.png" alt="image-20240530220958264" style="zoom:50%;" />



**回填和非回填翻译的比较**

回填|指令加入到true/falselist中|backpatch或merge
-|-|-
非回填|指令跳转到true/false|对true/false属性赋值

**Break、Continue的处理**

- break：break后加入一个N，生成GOTO指令，指令号加入S.nextlist中（n.nextlist与s.nextlist合并）
- continue：跳转到条件判断的位置

# 8 代码生成

![image-20240527143036075](编译原理.assets/image-20240527143036075.png)

## 基本块

最大连续的三地址指令序列，满足下列条件：

- 控制流只能从外部跳转到基本块的第一个指令
- 控制流在离开基本块之前不会发生跳转或停机，直到遇到最后一个指令才能跳出

### 基本块划分算法

1. 确定基本块的第一个指令 = 首指令（leader）
	- 序列中第一个三地址指令
	- 跳转指令的目标指令
	- 跳转指令的下一条指令
	- ![image-20240527144205142](编译原理.assets/image-20240527144205142.png)
2. 确定基本块
	- 每个首指令对应于一个基本块：从首指令开始，直到遇见下一个首指令，进行切分
	- ![image-20240527144216947](编译原理.assets/image-20240527144216947.png)

### 基本块的后续使用信息

对数据流进行分析：知道一个变量的值在之后会不会被使用

- 变量x在语句i后的程序点上活跃（live）：
	- 指令i：对变量x赋值
	- 指令j：使用了i处计算得到的x值（i到j上没有指令再对x赋值）
- 不活跃：变量的值不被使用（不是变量不被使用）

如果x再某处不活跃，可以把它占用的寄存器用来干别的

**确定后续使用信息的算法**

输入：基本块B，开始时B中的所有非临时变量都是活跃的

1. 从B的最后一个语句开始反向扫面
2. 对于每个语句 i ：x = y + z
	- 另语句 i 和x y z的当前活跃性 / 使用信息关联
		- x：不活跃 / 无后续使用
		- y、z：活跃 / 下一次使用为语句i
	- 特例：如果x=x+z，x活跃且被使用；如果访问数组x[t]=y+z，则x和t都活跃且被使用
	- 信息可以被累积到下一个语句，不活跃信息可以替代原先的活跃信息

输出：各个语句上变量的活跃性、后续使用信息

![image-20240527151752563](编译原理.assets/image-20240527151752563.png)

## 代码生成器概述

输入：中间表示 + 符号表

输出：（语义等价的）目标程序

![image-20240527152322376](编译原理.assets/image-20240527152322376.png)

**主要任务：**

- 指令选择：选择适当的指令实现中间表示
- 寄存器分配和指派：把哪个值放在哪个寄存器中
- 指令排序：按照什么顺序指令执

目标计算机的特点：

- 三地址机器模型
- 内存按照字节寻址
- 具有n个通用寄存器：R0,R1,...,Rn-1
- 假设所有的运算分量都是整数

**目标语言的指令类型：**

![image-20240527153713884](编译原理.assets/image-20240527153713884.png)

**目标语言的寻址模式：**

以下全部是地址

- 变量x：x所处内存地址
- a(r)：a的地址 + 寄存器r中的值
例如`LD R1, a(R2)`：R1 = contents( a + contents(R2) )

- constant(r)：constant位置处是一个常数数字，constant + 寄存器r中的值
例如`LD R1, 100(R2)`：R1 =  contents( 100 + contents(R2) )

- \* r：寄存器r中的值作为地址

- \* constant(r)：( constant + 寄存器r中的值 ) 地址处的值作为地址
例如`LD R1,*100(R2)`：R1 =  contents( contents( 100 + contents(R2) ) )

## 指令选择

**赋值语句 A = B**

首先把B中可能涉及到的所有变量加载到寄存器中，在寄存器中运算，并将运算结果留在寄存器中，B的情况可能为如下：

- 普通变量 x
	- `LD R, x`：将变量x从内存加载到寄存器
- 数组元素访问a[i]
	- `LD R1, i`：将索引i从内存加载到寄存器R1
	- `MUL R1, R1, 字节值`：在寄存器中计算偏移量
	- `LD R2, a(R1)`：数组寻址，将对应内容加载到寄存器中保存
- 指针访问 \*p
	- `LD R1, p`：将指针p从内存加载到寄存器R1，R1中存储的是指针中保存的地址
	- `LD R2, 0(R1)`：在内存中找到指针所指的地址，并将内容加载到寄存器R2中
- 运算 x op y
	- 假设 x和y 已经经过上面的步骤保存到寄存器 R1和R2 中
	- `OP R1, R1, R2`：在寄存器中运算并放回原先的寄存器

假设B的结果被保存到寄存器R中，将其保存到A中，A的情况可能为如下：

- 普通变量x
	- `ST x, R`
- 数组元素 a[j]
	- `LD R1, j`：加载索引
	- `MUL R1, R1, 字节值`：计算偏移量
	- `ST a(R1), R`：使用偏移量找到地址并保存结果
- 指针 \*p
	- `LD R1, p`：加载指针所存储的地址
	- `LD 0(R1), R`：找到地址所指的位置并保存结果

**条件跳转语句 if A goto L**

关系运算 $\Rightarrow$ 数学运算：寄存器中的值小于0就可以进行跳转

![image-20240527170001938](编译原理.assets/image-20240527170001938.png)


**指令代价**

内存寻址 / 运算 代价 + 1

![image-20240527181120318](编译原理.assets/image-20240527181120318.png)

## 寄存器分配和指派

**寄存器描述符（registerdescriptor）：**记录每个寄存器当前存放哪些变量的值

**地址描述符（addressdescriptor）：**记录运行时某个变量名对应的值存在哪个位置

- 位置可能是寄存器、栈单元、内存地址或者是它们的某个集合
- 可以存放在变量名对应的符号表条目中

**基本块的收尾处理：**对于在出口处可能**活跃的变量**，如果地址描述符不是描述x的内存位置（**需要更新到内存中**），则生成指令 `ST x, R`，R是存放x的寄存器

对每个形如 `x = y op z` 的三地址指令I，执行如下动作：

- 调用函数getreg(l) 为y z选择寄存器 Ry Rz
	- 如果y / z已经在某个寄存器中，选择该寄存器
	- 如果y / z不在寄存器中，且有空闲寄存器，选择一个寄存器并生成LD指令
		- R的寄存器描述符 = y
		- y的地址描述符.add(R)
		- 别的地址描述符中删除R
	- 如果y / z之后不再使用，可以让其保存运算结果作为Rx
- 生成运算操作的目标指令：`OP Rx, Ry, Rz`
	- Rx的寄存器描述符 = x
	- 别的寄存器描述符中删除x（因为x的值变了）
	- x的地址描述符 = Rx
	- 别的地址描述符中删除Rx

对于复制语句 `x = y`：

- 给y分配寄存器Ry并LD
- Ry的寄存器描述符.add(x)
- x的地址描述符 = Ry

**没有空闲寄存器时的处理方案**

假设找一个一个寄存器R，其中保存变量v（通过寄存器描述符得知）

- 若v的地址描述符中还有R之外的位置，把R作为空闲寄存器
- 若v是本次语句的赋值目标，且x不是运算分量，把R作为空闲寄存器
- 若v在此后不会被使用（不活跃），把R作为空闲寄存器
- 若以上都不满足，把v的寄存器值保存到内存中（溢出）`ST v, R`，v的地址描述符=v
若R中存放了多个变量的值，那么需要生成多条ST指令；尽量选择ST指令代价低的寄存器

## 窥孔优化

窥孔 (peephole)：程序上的滑动窗口

窥孔优化：检查目标指令的一个滑动窗口，用更快或更短的指令来优化窗口中的指令序列

可以在中间代码生成之后应用窥孔优化，提高中间表示形式的质量

### 冗余指令删除

**消除冗余的加载和保存指令**

```
ST a, R0
LD R0, a 
```

但是如果第2条指令具有指令块的标号，不可以删除

**消除不可达代码**

删除紧跟在**无条件跳转**之后的不带标号的指令

### 控制流优化

跳转到跳转指令的指令时，可以用一个跳转指令代替

![image-20240527194232452](编译原理.assets/image-20240527194232452.png)

### 代数优化

**代数恒等式**

消除窥孔中类似于x=x+0或x=x\*1的运算指令

**强度削弱**

- 对于乘数(除数)是2的幂的定点数乘法(除法) ，用移位运算实现代价比较低
- 除数为常量的浮点数除法可以通过乘数为该常量倒数的乘法来求近似

### 特殊指令的使用

利用目标系统的高效特殊指令来提高代码效率

例如：INC指令可以用来替代加1操作

# 9 机器无关的优化

## 流图

Flow Graphs

- 结点：基本块
- 基本块B到基本块C之间有一条边：C的第一个指令可能紧跟在B的最后一条指令之后执行
	- B是C的前驱(predecessor) ；C是B的后继(successor)

确认边的两种方式

- 存在跳转：从B的结尾跳转到C的开头
- 在原三四地址序列中，C紧跟在B后面，且B的结尾不存在无条件跳转语句

<span id="流图">![image-20240527211849432](编译原理.assets/image-20240527211849432.png)</span>

## 常用的代码优化方法

**优化分类**

- 机器无关优化：针对中间代码
- 机器相关优化：针对目标代码
- 局部代码优化：针对单个基本块
- 全局代码优化：面向多个基本块

### 删除公共子表达式

如果表达式被计算过，且其中变量的值没有发生过变化，则称其为公共子表达式

![image-20240527215259959](编译原理.assets/image-20240527215259959.png)

*[流图](#流图)删除子表达式的优化结果*

### 删除无用代码

**复制传播：**

- 优化算法会引入复制语句（形如x= y的赋值语句）
- 在复制 x=y 之后，尽量用 y 代替 x
*个人理解：y通常是临时变量，放在寄存器中，更方便取用*

![image-20240527220801382](编译原理.assets/image-20240527220801382.png)

**无用代码：**计算结果永远不会被使用的语句

![image-20240527221116221](编译原理.assets/image-20240527221116221.png)

*复制传播后，x=t3这一语句就无用了*

### 常量合并

Constant Folding

如果推导出的表达式值是常量，可以使用该常量来替代这个表达式

![image-20240527221433897](编译原理.assets/image-20240527221433897.png)

*如图 t1是一个常量，t2的计算中就用常量替代*

### 代码移动

Code Motion

循环不变计算（loop-invariant computation）：不论循环几次表达式的结果都相同

在进入循环之前就对它们求值，减少重复计算的次数

![image-20240527221740508](编译原理.assets/image-20240527221740508.png)

对于多重嵌套的循环，循环不变计算是相对的

### 强度削弱

Strength Reduction

用较快的操作代替较慢的操作，例如：用加代替乘，用乘替代除/幂

![image-20240527222001762](编译原理.assets/image-20240527222001762.png)

循环中的强度削弱

归纳变量：对一个变量x，存在一个常数c使得每次x被赋值时，值增加/减少c

归纳变量在循环中可以变成自增，但是注意进入循环前要先赋值，不如自增时没有内容

![image-20240527222505829](编译原理.assets/image-20240527222505829.png)

*t2和 t4 就是可以改为自增运算的归纳变量*

### 删除归纳变量

沿着循环运行时，如果有 一组归纳变量的值的变化保持步调一致，常可以将这组变量删除为只剩一个

![image-20240527222820745](编译原理.assets/image-20240527222820745.png)

*i>=j 替换为 t2>=t4：因为增幅（步调）刚好相差整数倍*

## 基本块的优化

局部优化技术之一：把一个基本块转换成为一个无环有向图DAG

**基本块的 DAG 表示**

对于形如x=y+z的三地址指令， 如果已经有一个结点表示y+z， 就不往DAG中增加新的结点， 而是给已经存在的结点附加定值变量 x
